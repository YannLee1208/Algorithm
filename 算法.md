

## 堆排序

与优先队列紧密相关

**堆一般拿来实现优先队列，而不拿来排序，排序效果不如快排，但是其优势在于动态插入删除**

### 介绍

* ex 
  * 在N个元素中选出前M个元素
  * 排序 : $\mathcal{O(NlogN)}$
  * 堆排序/优先队列 : $\mathcal{O(NlogM)}$
    * 保持堆的大小为 M个
* 优先队列的实现
  1. 普通数组
     * 入队 : O(1) 放到末尾
     * 出队 : O(n) 遍历找出优先级最高的
  2. 顺序数组
     * 入队: O(n) 遍历找出合适位置
     * 出队: O(1)
  3. 堆
     * 入队：O(logn)
     * 出队:  O(logn)



### 堆的实现

* 二叉堆 Binary Heap（最大堆为例）

  1. 左右孩子都小于父亲节点
  2. 完全二叉树
     * 除了最后一层节点外，其余层都满
     * 最后一层所有节点都集中在左侧

* 二叉堆实现

  * **利用完全二叉树的特点，使用数组存储二叉堆**

  1. 不使用第0位，从1开始索引
     * $parent(i) = \frac{i}{2}$
     * $left\ child\ (i) = 2\times i$
     * $right\ child\ (i) = 2\times i + 1$
  2. 使用第0位
     * $parent(i) = \frac{i-1}{2}$
     * $left\ child\ (i) = 2\times i + 1$
     * $right\ child\ (i) = 2\times i + 2$

### 插入删除元素

* shift up 插入元素

  1. 将新加入的元素插到数组最后

  2. 比较新元素与父节点的大小

     * 大于则交换

     * 小于则退出循环

     * ``````c++
       while (k > 1 && data[k/2]  < data[k]){
             swap( data[k/2], data[k]);
             k /= 2;}
       ``````

* shift down 取出元素

  1. 取出第一个元素(最大元素)

  2. 将最后的元素放到第一个位置

     * 保持了完全二叉树的性质

  3. 比较元素与子节点的大小

     * 大于则停止

     * 小于则和**左右子节点中更大的元素交换**

     * ```c++
        while (2 * k <= count){
                   // 确保有左孩子
                   // j 代表左右孩子中更大的index
                   int j = 2 * k;
                   if ( j + 1 <= count && data[j+1] > data[j])
                       j += 1;
                   if (data[k] >= data[j])
                       break;
                   swap(data[k], data[j]);
                   k = j;
               }
       ```



### Heapify

将一个数组整理成为堆的过程

* 流程

  1. 找出第一个不是叶子节点的点
     * 如果从1开始inde的话，是**count / 2**
     * 因为是最后一个节点的父节点
  2. 从该点开始， 从后往前依次shiftDown（**shiftDown需要一个参数k的原因**）

  ```c++
  for (int i = count / 2; i >= 1; --i) 
              shiftDown(i);
  ```

* 优势

  * 将n个元素逐个插入 ： O(nlogn)

  * heapify：O(n)

    * 最后一层父节点下调1次，倒数第二层下调2次 ...  高度H = logn,  最后一层父节点有 2^(H-1)个节点

      $T = 1 \times 2^{H-1} + 2 \times 2^{H-2} + .. (H-1)\times2^1 + H $

      $\rightarrow T = \sum_{1}^{logn} n\times k \times \frac{1}{2^k}$

      $T - 1/2 T = 1/2T = n\times (\frac{1}{2} + \frac{1}{4} + ..+\frac{1}{2^k} - \frac{k}{2^{k+1} })$

      $\rightarrow  T <= 2n$

  

### 优化

1. 原地堆排序

   * 不需要重新开辟一个空间

   * 将一个数组整理为有序数组的过程

   * **注意：shiftdown使用的前提是已经是heap了，只是某个元素不满足条件**

     * 对整个数组 **heapify **
     * 交换头元素和末尾元素 
       * 将最大值放到了最后
     * 对 0... n-1 个元素,  **对第0个元素进行shiftdown**
     * 交换头元素和第n-1个元素
     * 对 0... n-2 个元素，**对第0个元素进行shiftdown**
     * ...

   * ```c++
     void heapSort(T arr[], int n) {
       	// heapify
         for (int i = (n - 1) / 2; i >= 0; --i)
             _shiftDown(arr, n, i);
       	// shiftDown
         for (int i = n - 1; i > 0; --i) {
             swap(arr[0], arr[i]);
             _shiftDown(arr, i, 0);
         }
     }
     ```

2. 索引堆
   * 问题
     * 在进行heapify以后，再根据原来的index无法找到对应的元素
   * 方法
     * 添加一个index数组，在heapify中真正交换的是index数组
       * **indexs存储了堆中第i个位置在原data中的index**
       * indexs 是从 heap -> data 的映射
     * 此时比较的时候就要用 data[indexs[k]] 和 data[indexs[j]] 了
     * 而swap交换的也是indexs
   * **change操作**
     * 修改了某个index的元素值
     * **注意，此时要找出该元素在indexs数组中的位置 **
       * 找到indexs[j] = i, j 代表data[i] 在堆中的位置
       * 然后shiftup(j) 和 shiftDown(j)
     * O(n) 级别，因为要遍历
     * 解决方法
       * 添加一个reverse数组
         * reverse[i] 代表了data的第i个 **在indexs中的位置**
         * 是从 data -> heap 的映射





