

## 堆排序

与优先队列紧密相关

**堆一般拿来实现优先队列，而不拿来排序，排序效果不如快排，但是其优势在于动态插入删除**

### 介绍

* ex 
  * 在N个元素中选出前M个元素
  * 排序 : $\mathcal{O(NlogN)}$
  * 堆排序/优先队列 : $\mathcal{O(NlogM)}$
    * 保持堆的大小为 M个
* 优先队列的实现
  1. 普通数组
     * 入队 : O(1) 放到末尾
     * 出队 : O(n) 遍历找出优先级最高的
  2. 顺序数组
     * 入队: O(n) 遍历找出合适位置
     * 出队: O(1)
  3. 堆
     * 入队：O(logn)
     * 出队:  O(logn)



### 堆的实现

* 二叉堆 Binary Heap（最大堆为例）

  1. 左右孩子都小于父亲节点
  2. 完全二叉树
     * 除了最后一层节点外，其余层都满
     * 最后一层所有节点都集中在左侧

* 二叉堆实现

  * **利用完全二叉树的特点，使用数组存储二叉堆**

  1. 不使用第0位，从1开始索引
     * $parent(i) = \frac{i}{2}$
     * $left\ child\ (i) = 2\times i$
     * $right\ child\ (i) = 2\times i + 1$
  2. 使用第0位
     * $parent(i) = \frac{i-1}{2}$
     * $left\ child\ (i) = 2\times i + 1$
     * $right\ child\ (i) = 2\times i + 2$

### 插入删除元素

* shift up 插入元素

  1. 将新加入的元素插到数组最后

  2. 比较新元素与父节点的大小

     * 大于则交换

     * 小于则退出循环

     * ``````c++
       while (k > 1 && data[k/2]  < data[k]){
             swap( data[k/2], data[k]);
             k /= 2;}
       ``````

* shift down 取出元素

  1. 取出第一个元素(最大元素)

  2. 将最后的元素放到第一个位置

     * 保持了完全二叉树的性质

  3. 比较元素与子节点的大小

     * 大于则停止

     * 小于则和**左右子节点中更大的元素交换**

     * ```c++
        while (2 * k <= count){
                   // 确保有左孩子
                   // j 代表左右孩子中更大的index
                   int j = 2 * k;
                   if ( j + 1 <= count && data[j+1] > data[j])
                       j += 1;
                   if (data[k] >= data[j])
                       break;
                   swap(data[k], data[j]);
                   k = j;
               }
       ```



### Heapify

将一个数组整理成为堆的过程

* 流程

  1. 找出第一个不是叶子节点的点
     * 如果从1开始inde的话，是**count / 2**
     * 因为是最后一个节点的父节点
  2. 从该点开始， 从后往前依次shiftDown（**shiftDown需要一个参数k的原因**）

  ```c++
  for (int i = count / 2; i >= 1; --i) 
              shiftDown(i);
  ```

* 优势

  * 将n个元素逐个插入 ： O(nlogn)

  * heapify：O(n)

    * 最后一层父节点下调1次，倒数第二层下调2次 ...  高度H = logn,  最后一层父节点有 2^(H-1)个节点

      $T = 1 \times 2^{H-1} + 2 \times 2^{H-2} + .. (H-1)\times2^1 + H $

      $\rightarrow T = \sum_{1}^{logn} n\times k \times \frac{1}{2^k}$

      $T - 1/2 T = 1/2T = n\times (\frac{1}{2} + \frac{1}{4} + ..+\frac{1}{2^k} - \frac{k}{2^{k+1} })$

      $\rightarrow  T <= 2n$

  

### 优化

1. 原地堆排序

   * 不需要重新开辟一个空间

   * 将一个数组整理为有序数组的过程

   * **注意：shiftdown使用的前提是已经是heap了，只是某个元素不满足条件**

     * 对整个数组 **heapify **
     * 交换头元素和末尾元素 
       * 将最大值放到了最后
     * 对 0... n-1 个元素,  **对第0个元素进行shiftdown**
     * 交换头元素和第n-1个元素
     * 对 0... n-2 个元素，**对第0个元素进行shiftdown**
     * ...

   * ```c++
     void heapSort(T arr[], int n) {
       	// heapify
         for (int i = (n - 1) / 2; i >= 0; --i)
             _shiftDown(arr, n, i);
       	// shiftDown
         for (int i = n - 1; i > 0; --i) {
             swap(arr[0], arr[i]);
             _shiftDown(arr, i, 0);
         }
     }
     ```

2. 索引堆
   * 问题
     * 在进行heapify以后，再根据原来的index无法找到对应的元素
   * 方法
     * 添加一个index数组，在heapify中真正交换的是index数组
       * **indexs存储了堆中第i个位置在原data中的index**
       * indexs 是从 heap -> data 的映射
     * 此时比较的时候就要用 data[indexs[k]] 和 data[indexs[j]] 了
     * 而swap交换的也是indexs
   * **change操作**
     * 修改了某个index的元素值
     * **注意，此时要找出该元素在indexs数组中的位置**
       * 找到indexs[j] = i, j 代表data[i] 在堆中的位置
       * 然后shiftup(j) 和 shiftDown(j)
     * O(n) 级别，因为要遍历
     * 解决方法
       * 添加一个reverse数组
         * reverse[i] 代表了data的第i个 **在indexs中的位置**
         * 是从 data -> heap 的映射





## 树



### 二叉搜索树

**用于查找数据, 实现查找表 / 字典 (key - value)** 

搜索/插入/查找 O(logn)



**定义**

* 二叉树
  * 每个节点的键值大于左孩子
  * 小于右孩子
  * 以左右孩子为根的子树仍然为二分搜索树( **递归结构** )
  * **不一定是完全二叉树，所以不能用数组表示二叉搜索树**



**方法**

* insert

  * 使用递归实现，比较key和当前node的key

  * ```c++
    Node* insert(Node* node, Key key, Value value){
            if (node == NULL){
                count ++;
                return new Node(key, value);
            }
            if (key == node->key)
                node->value = value;
            else if ( key < node->key)
                node->left = insert(node->left, key, value);
            else
                node->right = insert( node->right, key, value);
        }
    ```

* search / contain

  * 与insert类似
  * 注意search的返回值
    * Node* ? : **暴露了Node类，不是一个好的封装**
    * Value? : **需要配合contain使用，因为不能返回一个NULL**
    * **Value*** ： 允许返回NULL

* delete 

  1. 删除最大值/最小值 **/只有左孩子或者右孩子的节点**

     * 找出最小值/最大值的节点

       * **最左节点/最右节点**

     * 如果最小值没有右孩子(**最小值只有右孩子没有左孩子**

       * 直接删除

     * 如果最小值有右孩子

       * 将右孩子代替当前的节点

     * ```c++
       Node * removeMin(Node* node){
               if (node->left == NULL){        
                   Node* rightNode = node->right;
                   delete node;
                   count --;
                   return rightNode;
               }        
               node->left = removeMin(node->left);
               return node;
           }
       ```

  2. 同时有左孩子和右孩子的节点

     * 找到s代替当前节点d

       * **右子树的最小值/左子树的最大值**
       * s = min(d->right) / s = max(d->left)
       * s->right = delMin(d->right)
       * s->left = d->left 

     * ```c++
       Node *succesor = new Node(minNode(node->right));
       count ++;
       succesor->right = removeMin(node->right);
       succesor->left = node->left;
       delete node;
       count --;
       
       return succesor;
       ```

       



**遍历**

**递归很简单，重点考虑一下非递归**

* 前序

  * 实现

    * 考虑递归的系统内部，实际上是一个栈，通过不断出栈入栈

    * 模拟系统栈：**先推入右孩子，再推入左孩子，最后推入当前元素**

    * **出栈时进行相应操作**

    * ```c++
      void preOrderNonCur(){
              if (root == NULL)
                  return;
              stack<Node*> stack;
              stack.push(root);
              while ( !stack.empty()){
                  Node * node = stack.top();
                  stack.pop();
                  cout << node->value;
                  if (node->right != NULL)
                      stack.push(node->right);
                  if (node->left != NULL)
                      stack.push(node->left);
              }
          }
      ```

      

  * ```c++
     void preorderTraversalNew(Node *root, vector<Value> &path)
        {
            stack< pair<Node *, bool> > s;
            s.push(make_pair(root, false));
            bool visited;
            while(!s.empty())
            {
                root = s.top().first;
                visited = s.top().second;
                s.pop();
                if(root == NULL)
                    continue;
                if(visited)
                {
                    path.push_back(root->val);
                }
                else
                {
                    s.push(make_pair(root->right, false));
                    s.push(make_pair(root->left, false));
                    s.push(make_pair(root, true));
                }
            }
        }
    ```

    

* 中序

  * ```c++
    void inorderTraversalNew(TreeNode *root, vector<int> &path)
    {
        stack< pair<TreeNode *, bool> > s;
        s.push(make_pair(root, false));
        bool visited;
        while(!s.empty())
        {
            root = s.top().first;
            visited = s.top().second;
            s.pop();
            if(root == NULL)
                continue;
            if(visited)
            {
                path.push_back(root->val);
            }
            else
            {
                s.push(make_pair(root->right, false));
                s.push(make_pair(root, true));
                s.push(make_pair(root->left, false));
            }
        }
    }
    ```

    

* 后序

  * 实现

    * ```c++
      void postorderTraversalNew(TreeNode *root, vector<int> &path)
      {
          stack< pair<TreeNode *, bool> > s;
          s.push(make_pair(root, false));
          bool visited;
          while(!s.empty())
          {
              root = s.top().first;
              visited = s.top().second;
              s.pop();
              if(root == NULL)
                  continue;
              if(visited)
              {
                  path.push_back(root->val);
              }
              else
              {
                  s.push(make_pair(root, true));
                  s.push(make_pair(root->right, false));
                  s.push(make_pair(root->left, false));
              }
          }
      }
      ```

      

  * 应用

    * **BST的析构函数**

* 广度优先遍历(层序遍历)

  * **使用队列Queue**

  * ```c++
    void levelOrder(){        
            queue<Node*> q;
            q.push(root);
            while (!q.empty()){
                Node *node = q.pop();
                cout << node->value;        
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
        }
    ```

* 深度优先遍历
  
  * 使用Stack（前序）



**局限**

* 有可能会退化成链表
  * 按顺序插入





### 集合与映射

* 集合

**去重**，没有重复元素

```c++
template <typename T>
class Set {
    virtual void add(T e) = 0;

    virtual void remove(T e) = 0;

    virtual bool contains(T e) = 0;

    virtual int getSize() = 0;

    virtual bool isEmpty() = 0;
};
```



**BST和LinkedList都是动态数据结构**

**基于BST实现** 

* bst对于重复元素是没有多余操作的

**基于LinkedList**

| Opetation | LinkedList | BST     |
| --------- | ---------- | ------- |
| Add       | O(n)       | O(logn) |
| Contains  | O(n)       | O(logn) |
| Remove    | O(n)       | O(logn) |



* 映射 Map
  * 在Set的基础上修改Node即可



### 线段树

* 经典问题：区间染色问题

  * **如果是静态的查询区间问题  如 求 [i,..j]的和**

    * 只需要在接受数据时，创建一个sum数组代表从0到i - 1的数据和
    * 然后sum[j] - sum[i] 即可
    * **线段树的优势在于动态更新**

  * 问题

    * m次染色后，在[i, j] 区间内看见多少种颜色

  * 操作

    * | Operation     | Array | SegmentTree |
      | :------------ | ----- | ----------- |
      | 染色/更新区间 | O(n)  | O(logn)     |
      | 查询          | O(n)  | O(logn)     |

  * 实质

    * 基于**区间的统计查询**
    * 对于给定区间实现
      * 更新一个元素的值或者多个区间的值
      * 查询某个区间的某些信息

* 实现

  * 二叉树

    * <img src="./Image/SegTree.jpg" alt="SegTree" style="zoom:50%;" />

    * 叶子节点存储每个元素的值，不一定是满二叉树/完全二叉树
    * **是平衡二叉树：最大深度和最小深度的差只能为1**

  * 使用数组表示平衡二叉树

    * 对满二叉树 : h 层 一共有 $2^h-1$ 个节点，大约有 $2^h$,  最后一层 (h - 1 层)， 有 $2^{h-1}$ 个节点
      * 最后一层的节点数大致等于前面所有节点数之和
    * 如果区间有n个元素
      * $n = 2^k$ :  需要 2n 空间 （最后一层为n个叶子结点，而上面的节点之和大致也为n，此时和为2n）
      *  $n = 2^k + 1$ (最坏情况) 时，最后一层的上面有2n个结点，因此总和为4n
      * **用 4n 的数组存储**

* 操作

  * 创建线段树（递归）

    * 根节点的值是左右孩子的值的和

    * 自底向上创建

      * ```c++
        // 在tree数组的treeIndex位置创建表示区间[l,..r]的线段树
        void buildSegmentTree(int treeIndex, int l, int r)
        ```

  * 查询

    * 递归查找，从上往下

    * 实际上为了获取每个treeIndex的l和r，也可以存为Node类型

    * ```c++
      // 在以treeIndex为根 treeIndex的范围是 l和r 查找queryL和queryR
      T query(int treeIndex, int l, int r, int queryL, int queryR){}
      ```

  * 更新

    * 递归

    * ```c++
       void set(int treeIndex, int l, int r, int index, T t){}
      ```





### Trie

**专门为字典设计的**

* 查询

  * | 操作 | Trie                               | 字典                  |
    | ---- | :--------------------------------- | --------------------- |
    | 查询 | O(w) w为查询长度，与字典中条目无关 | O(logn) 如果有n个条目 |

    因为绝大多数单词长度很小，所以Trie有很大的优势

  * <img src="./Image/Trie.PNG" alt="Trie" style="zoom:30%;" />

    * 每个节点有若干个指向下个节点的指针

    * ```c++
      class Node{
        // char c;
        bool isWord;
        Node next[26]; -> Map<char, Node> next;
      }
      ```

    * 因为不确定是否需要全部存储所有的26个字母，所以用map 存储

    * **实际上查询的时候在到达Node之前就已经知道要查询什么了，所以这个c实际上是不必要的**

    * **isWord代表从根到该节点是否为单词，因为有可能某个单词前缀也是一个单词**

* 实现

  * add 
    * 递归 类似二叉树
    * 非递归 见代码
  * contain
    * 与add类似
  * isPrefix 前缀查询



### AVL

* 平衡二叉树

  * 对于任意一个节点，左右子树高度差不能超过1

* 平衡因子 Balance Factor

  * 某个节点左右子树的高度差

  * ```c++
    int getBalanceFactor(Node *node) {
            if (node == nullptr) {
                return 0;
            }
            return getHeight(node->left) - getHeight(node->right);
        }
    ```

* 辅助函数
  *  isBST()
    * 检查是否为BST **左节点小于右节点**
    * **借助中序遍历是从小到大判断是否是BST**
  * isBalanced()
    * 判断是否是平衡二叉树 (递归函数)
  
* 如何维护平衡

  * 自底向上更新balanceFactor,  同时维护平衡

    * **在add函数内，更新完balanceFactor后进行操作**
* 当导致不平衡的节点出现在 **该节点左子树的左侧LL**
  
  * `balanceFactor >  1 && getBalanceFactor(node->left) >= 0`
  * **右旋转 y向右转 （顺时针）** 
  * <img src="./Image/RightRotation.jpeg" alt="RightRotation" style="zoom:30%;" />
    
  * 是否满足二叉树？
      * 根据大小关系可以判断满足
    * 是否满足平衡二叉树？
        * 变换前
          * z本身满足 若T1，T2最大高度为h，则**z为h+1**
          * 因为x本来是平衡的，且左偏 -> **T3高度 h 或 h+1** -> **x 高度 h+2**
          * 因为 y 不平衡 且左偏 -> **T4为h**
        * 变换后
          * T3为 h 或 h+1 T4为h -> **y为h+1或 h+2且平衡**
          * **z为h+1 平衡**
          * **x平衡**
  * 当导致不平衡的节点出现在 **该节点右子树的右侧RR**
  
    * `balanceFactor < -1 && getBalanceFactor(node->right) <= 0`
    * **注意是getBalanceFactor(node->right) <= 0`**
    * **左旋转 y向左转 逆时针**
    * x->left = y;
      * y->right = T3;
  * **左子树的右侧LR -> 先 leftRotation再 rightRotation**
  * **注意 leftRotation是对于x的，rightRotation是对于y的**
    * <img src="./Image/LR1.jpeg" alt="LR1" style="zoom:20%;" />
    * <img src="./Image/LR2.jpeg" alt="LR2" style="zoom:20%;" />
* **右子树的左侧RL -> 先 rightRotation再 leftRotation**

* 删除元素
  
  * 在BST的基础上，先存储要return的Node，和add一样更新height，计算balanceFactor并且判断四种情况







## Hash

**Hash表不需要 Comparable，但是在我的实现中，AVLTree需要Comparable的，这是一个小bug**



### 哈希函数的设计

* 目标

  * 键通过哈希函数得到的索引分布越均匀越好

* 原则

  * 一致性：a==b 则 hash(a) == hash(b)
  * 高效性：计算高效
  * 均匀性：哈希值分布均匀

* 一般的设计方法

  * **转换为整型**
    * 小范围正整数直接使用
    * 小范围负整数 -100 ~ 100 -> 0 ~ 200
    * 大整数
      * 取模
        * 取后四位 -> mod 10000
        * 取后六位 -> mod 1000000
          * **但是注意，如果是身份证号，后六位最大只能为319999**
          * 分布不均匀 且没有利用所有信息则添加了哈希冲突的可能
        * **模一个素数**

  * 浮点型

    * 将浮点型的32位或64位当作整型处理

  * 字符串

    * 转为整型 

      * $code = c*26^3 + o * 26^2 + d * 26^1 + e * 26^0$

      * 如果还要考虑别的字符，则当作一个B进制的整型

      * $hash(code) = (c*B^3 + o * B^2 + d * B^1 + e * B^0) \% M$

        *  $hash(code) = ((c*B) + o) *B  + d )* B + e ) B) \% M$
        * **这样可以避免直接算B的n次方**
        * $hash(code) = (((c \% M)*B) + o) \%M   + d ) \% M* B + e )\%M * B^0) $
        * **避免整型溢出**

      * ```c++
        int hash = 0;
        for(int i = 0; i < s.size(); i ++)
          hash = (hash * B + s[i]) % M;
        ```

  

### Seperate Chaining

* (hashCode(x) & 0x7fffffff ) % M
  * 0x7fffffff -> 31个1 
  * 最高位是符号位 -> 把x的最高位变为0, 其他位不变
  * **去符号**
* Seperate Chining
  * 对于哈希冲突，用 链表/TreeMap 存储
  * <img src="./Image/Hash.jpeg" alt="Hash" style="zoom:33%;" />
  * 在Java中，刚开始用链表，哈希冲突到一定程度时，转换为**红黑树**
    * **如果要转为红黑树，必须是Comparable的**



### 更多冲突方法

* 开放地址法 open addressing
  * 线性探测
    * 如果产生哈希冲突，则找离该位置下一个最近的空的地址放进去
  * 平方探测
    * 如果遇到冲突，先 +1 尝试，则+4，再 +9 去找空位 避免一整片被占满
  * 二次哈希
    * 如果冲突，再用第二种哈希函数找加几个位置
* 再哈希法
  * 冲突的话，再用另一个哈希
* Coalesced Hashing
  * 结合了 Seperate Chaining和 open addressing



### 动态空间处理

* 若总共有M个地址，N个元素

  * 如果每个地址是链表 : O(N/M)
  * 平衡树: O(log(N/M))

* 如果固定地址空间 无法做到 O(1) -> 动态空间

  * **平均每个地址承载元素多过一定程度，扩容.  N/M >= upperTol**
  * **平均每个地址承载元素少于一定程度，缩容.  N/M <= lowerTol**

* 平均是O(1) 级别的 因为每次扩容缩容为 O(n) 但n次操作均摊变成 O(1)

* 优化

  M可能不是素数了

  * **加一个capacityList， 每次加减 capacityList的index **



### 讨论

* 缺点
  * **失去了顺序性**
* 优点
  * 均摊时间复杂度为 O(1)





## Tricky

* 完全二叉树/平衡二叉树可以用数组表示
  * 完全二叉树 -> 见堆排序
  * 平衡二叉树
    * **对于最后一层多余的节点，只要在数组中多开辟点空间就行了**





