

## 堆排序

与优先队列紧密相关

**堆一般拿来实现优先队列，而不拿来排序，排序效果不如快排，但是其优势在于动态插入删除**

### 介绍

* ex 
  * 在N个元素中选出前M个元素
  * 排序 : $\mathcal{O(NlogN)}$
  * 堆排序/优先队列 : $\mathcal{O(NlogM)}$
    * 保持堆的大小为 M个
* 优先队列的实现
  1. 普通数组
     * 入队 : O(1) 放到末尾
     * 出队 : O(n) 遍历找出优先级最高的
  2. 顺序数组
     * 入队: O(n) 遍历找出合适位置
     * 出队: O(1)
  3. 堆
     * 入队：O(logn)
     * 出队:  O(logn)



### 堆的实现

* 二叉堆 Binary Heap（最大堆为例）

  1. 左右孩子都小于父亲节点
  2. 完全二叉树
     * 除了最后一层节点外，其余层都满
     * 最后一层所有节点都集中在左侧

* 二叉堆实现

  * **利用完全二叉树的特点，使用数组存储二叉堆**

  1. 不使用第0位，从1开始索引
     * $parent(i) = \frac{i}{2}$
     * $left\ child\ (i) = 2\times i$
     * $right\ child\ (i) = 2\times i + 1$
  2. 使用第0位
     * $parent(i) = \frac{i-1}{2}$
     * $left\ child\ (i) = 2\times i + 1$
     * $right\ child\ (i) = 2\times i + 2$

### 插入删除元素

* shift up 插入元素

  1. 将新加入的元素插到数组最后

  2. 比较新元素与父节点的大小

     * 大于则交换

     * 小于则退出循环

     * ``````c++
       while (k > 1 && data[k/2]  < data[k]){
             swap( data[k/2], data[k]);
             k /= 2;}
       ``````

* shift down 取出元素

  1. 取出第一个元素(最大元素)

  2. 将最后的元素放到第一个位置

     * 保持了完全二叉树的性质

  3. 比较元素与子节点的大小

     * 大于则停止

     * 小于则和**左右子节点中更大的元素交换**

     * ```c++
        while (2 * k <= count){
                   // 确保有左孩子
                   // j 代表左右孩子中更大的index
                   int j = 2 * k;
                   if ( j + 1 <= count && data[j+1] > data[j])
                       j += 1;
                   if (data[k] >= data[j])
                       break;
                   swap(data[k], data[j]);
                   k = j;
               }
       ```



### Heapify

将一个数组整理成为堆的过程

* 流程

  1. 找出第一个不是叶子节点的点
     * 如果从1开始inde的话，是**count / 2**
     * 因为是最后一个节点的父节点
  2. 从该点开始， 从后往前依次shiftDown（**shiftDown需要一个参数k的原因**）

  ```c++
  for (int i = count / 2; i >= 1; --i) 
              shiftDown(i);
  ```

* 优势

  * 将n个元素逐个插入 ： O(nlogn)

  * heapify：O(n)

    * 最后一层父节点下调1次，倒数第二层下调2次 ...  高度H = logn,  最后一层父节点有 2^(H-1)个节点

      $T = 1 \times 2^{H-1} + 2 \times 2^{H-2} + .. (H-1)\times2^1 + H $

      $\rightarrow T = \sum_{1}^{logn} n\times k \times \frac{1}{2^k}$

      $T - 1/2 T = 1/2T = n\times (\frac{1}{2} + \frac{1}{4} + ..+\frac{1}{2^k} - \frac{k}{2^{k+1} })$

      $\rightarrow  T <= 2n$

  

### 优化

1. 原地堆排序

   * 不需要重新开辟一个空间

   * 将一个数组整理为有序数组的过程

   * **注意：shiftdown使用的前提是已经是heap了，只是某个元素不满足条件**

     * 对整个数组 **heapify **
     * 交换头元素和末尾元素 
       * 将最大值放到了最后
     * 对 0... n-1 个元素,  **对第0个元素进行shiftdown**
     * 交换头元素和第n-1个元素
     * 对 0... n-2 个元素，**对第0个元素进行shiftdown**
     * ...

   * ```c++
     void heapSort(T arr[], int n) {
       	// heapify
         for (int i = (n - 1) / 2; i >= 0; --i)
             _shiftDown(arr, n, i);
       	// shiftDown
         for (int i = n - 1; i > 0; --i) {
             swap(arr[0], arr[i]);
             _shiftDown(arr, i, 0);
         }
     }
     ```

2. 索引堆
   * 问题
     * 在进行heapify以后，再根据原来的index无法找到对应的元素
   * 方法
     * 添加一个index数组，在heapify中真正交换的是index数组
       * **indexs存储了堆中第i个位置在原data中的index**
       * indexs 是从 heap -> data 的映射
     * 此时比较的时候就要用 data[indexs[k]] 和 data[indexs[j]] 了
     * 而swap交换的也是indexs
   * **change操作**
     * 修改了某个index的元素值
     * **注意，此时要找出该元素在indexs数组中的位置**
       * 找到indexs[j] = i, j 代表data[i] 在堆中的位置
       * 然后shiftup(j) 和 shiftDown(j)
     * O(n) 级别，因为要遍历
     * 解决方法
       * 添加一个reverse数组
         * reverse[i] 代表了data的第i个 **在indexs中的位置**
         * 是从 data -> heap 的映射





## 树



### 二叉搜索树

**用于查找数据, 实现查找表 / 字典 (key - value)** 

搜索/插入/查找 O(logn)



**定义**

* 二叉树
  * 每个节点的键值大于左孩子
  * 小于右孩子
  * 以左右孩子为根的子树仍然为二分搜索树( **递归结构** )
  * **不一定是完全二叉树，所以不能用数组表示二叉搜索树**



**方法**

* insert

  * 使用递归实现，比较key和当前node的key

  * ```c++
    Node* insert(Node* node, Key key, Value value){
            if (node == NULL){
                count ++;
                return new Node(key, value);
            }
            if (key == node->key)
                node->value = value;
            else if ( key < node->key)
                node->left = insert(node->left, key, value);
            else
                node->right = insert( node->right, key, value);
        }
    ```

* search / contain

  * 与insert类似
  * 注意search的返回值
    * Node* ? : **暴露了Node类，不是一个好的封装**
    * Value? : **需要配合contain使用，因为不能返回一个NULL**
    * **Value*** ： 允许返回NULL

* delete 

  1. 删除最大值/最小值 **/只有左孩子或者右孩子的节点**

     * 找出最小值/最大值的节点

       * **最左节点/最右节点**

     * 如果最小值没有右孩子(**最小值只有右孩子没有左孩子**

       * 直接删除

     * 如果最小值有右孩子

       * 将右孩子代替当前的节点

     * ```c++
       Node * removeMin(Node* node){
               if (node->left == NULL){        
                   Node* rightNode = node->right;
                   delete node;
                   count --;
                   return rightNode;
               }        
               node->left = removeMin(node->left);
               return node;
           }
       ```

  2. 同时有左孩子和右孩子的节点

     * 找到s代替当前节点d

       * **右子树的最小值/左子树的最大值**
       * s = min(d->right) / s = max(d->left)
       * s->right = delMin(d->right)
       * s->left = d->left 

     * ```c++
       Node *succesor = new Node(minNode(node->right));
       count ++;
       succesor->right = removeMin(node->right);
       succesor->left = node->left;
       delete node;
       count --;
       
       return succesor;
       ```

       



**遍历**

**递归很简单，重点考虑一下非递归**

* 前序

  * 实现

    * 考虑递归的系统内部，实际上是一个栈，通过不断出栈入栈

    * 模拟系统栈：**先推入右孩子，再推入左孩子，最后推入当前元素**

    * **出栈时进行相应操作**

    * ```c++
      void preOrderNonCur(){
              if (root == NULL)
                  return;
              stack<Node*> stack;
              stack.push(root);
              while ( !stack.empty()){
                  Node * node = stack.top();
                  stack.pop();
                  cout << node->value;
                  if (node->right != NULL)
                      stack.push(node->right);
                  if (node->left != NULL)
                      stack.push(node->left);
              }
          }
      ```

      

  * ```c++
     void preorderTraversalNew(Node *root, vector<Value> &path)
        {
            stack< pair<Node *, bool> > s;
            s.push(make_pair(root, false));
            bool visited;
            while(!s.empty())
            {
                root = s.top().first;
                visited = s.top().second;
                s.pop();
                if(root == NULL)
                    continue;
                if(visited)
                {
                    path.push_back(root->val);
                }
                else
                {
                    s.push(make_pair(root->right, false));
                    s.push(make_pair(root->left, false));
                    s.push(make_pair(root, true));
                }
            }
        }
    ```

    

* 中序

  * ```c++
    void inorderTraversalNew(TreeNode *root, vector<int> &path)
    {
        stack< pair<TreeNode *, bool> > s;
        s.push(make_pair(root, false));
        bool visited;
        while(!s.empty())
        {
            root = s.top().first;
            visited = s.top().second;
            s.pop();
            if(root == NULL)
                continue;
            if(visited)
            {
                path.push_back(root->val);
            }
            else
            {
                s.push(make_pair(root->right, false));
                s.push(make_pair(root, true));
                s.push(make_pair(root->left, false));
            }
        }
    }
    ```

    

* 后序

  * 实现

    * ```c++
      void postorderTraversalNew(TreeNode *root, vector<int> &path)
      {
          stack< pair<TreeNode *, bool> > s;
          s.push(make_pair(root, false));
          bool visited;
          while(!s.empty())
          {
              root = s.top().first;
              visited = s.top().second;
              s.pop();
              if(root == NULL)
                  continue;
              if(visited)
              {
                  path.push_back(root->val);
              }
              else
              {
                  s.push(make_pair(root, true));
                  s.push(make_pair(root->right, false));
                  s.push(make_pair(root->left, false));
              }
          }
      }
      ```

      

  * 应用

    * **BST的析构函数**

* 广度优先遍历(层序遍历)

  * **使用队列Queue**

  * ```c++
    void levelOrder(){        
            queue<Node*> q;
            q.push(root);
            while (!q.empty()){
                Node *node = q.pop();
                cout << node->value;        
                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
        }
    ```

* 深度优先遍历
  
  * 使用Stack（前序）



**局限**

* 有可能会退化成链表
  * 按顺序插入





### 集合与映射

* 集合

**去重**，没有重复元素

```c++
template <typename T>
class Set {
    virtual void add(T e) = 0;

    virtual void remove(T e) = 0;

    virtual bool contains(T e) = 0;

    virtual int getSize() = 0;

    virtual bool isEmpty() = 0;
};
```



**BST和LinkedList都是动态数据结构**

**基于BST实现** 

* bst对于重复元素是没有多余操作的

**基于LinkedList**

| Opetation | LinkedList | BST     |
| --------- | ---------- | ------- |
| Add       | O(n)       | O(logn) |
| Contains  | O(n)       | O(logn) |
| Remove    | O(n)       | O(logn) |



* 映射 Map
  * 在Set的基础上修改Node即可



### 线段树

* 经典问题：区间染色问题

  * **如果是静态的查询区间问题  如 求 [i,..j]的和 **

    * 只需要在接受数据时，创建一个sum数组代表从0到i - 1的数据和
    * 然后sum[j] - sum[i] 即可
    * **线段树的优势在于动态更新**

  * 问题

    * m次染色后，在[i, j] 区间内看见多少种颜色

  * 操作

    * | Operation     | Array | SegmentTree |
      | :------------ | ----- | ----------- |
      | 染色/更新区间 | O(n)  | O(logn)     |
      | 查询          | O(n)  | O(logn)     |

  * 实质

    * 基于**区间的统计查询**
    * 对于给定区间实现
      * 更新一个元素的值或者多个区间的值
      * 查询某个区间的某些信息

* 实现

  * 二叉树

    * <img src="/Users/apple/Desktop/CS/算法/Algorithm/Image/SegTree.jpg" alt="SegTree" style="zoom:50%;" />

    * 叶子节点存储每个元素的值，不一定是满二叉树/完全二叉树
    * **是平衡二叉树：最大深度和最小深度的差只能为1**

  * 使用数组表示平衡二叉树

    * 对满二叉树 : h 层 一共有 $2^h-1$ 个节点，大约有 $2^h$,  最后一层 (h - 1 层)， 有 $2^{h-1}$ 个节点
      * 最后一层的节点数大致等于前面所有节点数之和
    * 如果区间有n个元素
      * $n = 2^k$ :  需要 2n 空间 （最后一层为n个叶子结点，而上面的节点之和大致也为n，此时和为2n）
      *  $n = 2^k + 1$ (最坏情况) 时，最后一层的上面有2n个结点，因此总和为4n
      * **用 4n 的数组存储**

* 操作

  * 创建线段树（递归）

    * 根节点的值是左右孩子的值的和

    * 自底向上创建

      * ```c++
        // 在tree数组的treeIndex位置创建表示区间[l,..r]的线段树
        void buildSegmentTree(int treeIndex, int l, int r)
        ```

  * 查询

    * 递归查找，从上往下

    * 实际上为了获取每个treeIndex的l和r，也可以存为Node类型

    * ```c++
      // 在以treeIndex为根 treeIndex的范围是 l和r 查找queryL和queryR
      T query(int treeIndex, int l, int r, int queryL, int queryR){}
      ```

  * 更新

    * 递归

    * ```c++
       void set(int treeIndex, int l, int r, int index, T t){}
      ```

  







## Tricky

* 完全二叉树/平衡二叉树可以用数组表示
  * 完全二叉树 -> 见堆排序
  * 平衡二叉树
    * **对于最后一层多余的节点，只要在数组中多开辟点空间就行了**





